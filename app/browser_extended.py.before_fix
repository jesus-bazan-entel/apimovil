"""
Extensi√≥n de DigiPhone con Rotaci√≥n Autom√°tica de Proxies
Archivo: app/browser_extended.py

Este archivo extiende DigiPhone con capacidades de rotaci√≥n autom√°tica
sin modificar el c√≥digo original de browser.py
"""

from app.browser import DigiPhone
from app.proxy_rotation_system import get_proxy_rotator, make_request_with_rotation
import requests
import logging

logger = logging.getLogger(__name__)


class DigiPhoneWithRotation(DigiPhone):
    """
    Extensi√≥n de DigiPhone que agrega rotaci√≥n autom√°tica de proxies
    """
    
    def __init__(self, user, reprocess=False):
        """Inicializa DigiPhone con rotaci√≥n"""
        super().__init__(user, reprocess)
        self.rotator = get_proxy_rotator()
        self.rotation_enabled = True
        self.max_rotation_retries = 3
    
    def _make_request_with_rotation(self, method, url, **kwargs):
        """
        Wrapper para hacer peticiones con rotaci√≥n autom√°tica
        """
        if not self.rotation_enabled:
            # Si rotaci√≥n est√° deshabilitada, usar m√©todo original
            return self.session.request(method, url, **kwargs)
        
        max_retries = kwargs.pop('max_retries', self.max_rotation_retries)
        
        for attempt in range(max_retries):
            # Hacer petici√≥n con rotaci√≥n
            response, new_proxy_index = make_request_with_rotation(
                session=self.session,
                method=method,
                url=url,
                proxy_index=self.index_proxy,
                max_retries=1,  # Un intento por proxy
                **kwargs
            )
            
            if response is not None:
                # √âxito
                return response
            
            # Fall√≥ o fue muy lento - rotar proxy
            if attempt < max_retries - 1:
                logger.info(f"üîÑ Rotando proxy (intento {attempt + 2}/{max_retries})")
                self._rotate_to_best_proxy()
                # Recrear sesi√≥n con nuevo proxy
                self._update_session_with_current_proxy()
            
        logger.error(f"‚ùå Fall√≥ petici√≥n despu√©s de {max_retries} rotaciones")
        return None
    
    def _rotate_to_best_proxy(self):
        """Rota al mejor proxy disponible seg√∫n m√©tricas"""
        if self._len_proxy == 0:
            logger.error("‚ùå No hay proxies disponibles")
            return
        
        # Obtener mejor proxy
        best_index = self.rotator.get_best_proxy_index(self._len_proxy)
        
        if best_index != self.index_proxy:
            old_index = self.index_proxy
            self.index_proxy = best_index
            logger.info(f"üîÑ Proxy rotado: {old_index} ‚Üí {best_index}")
        else:
            logger.info(f"‚ÑπÔ∏è Manteniendo proxy actual: {self.index_proxy}")
    
    def _update_session_with_current_proxy(self):
        """Actualiza la sesi√≥n con el proxy actual"""
        if self._len_proxy == 0:
            return
        
        # Obtener configuraci√≥n del proxy actual
        proxy_config = self.listproxy[self.index_proxy]
        
        # Crear nueva sesi√≥n con el proxy actual
        self.session = requests.Session()
        self.session.proxies = {
            "http": proxy_config['http'],
            "https": proxy_config['https']
        }
        
        # Limpiar cookies previas
        self.cookies = None
        
        logger.info(f"üîÑ Sesi√≥n actualizada con proxy {self.index_proxy}")
    
    def get_access(self, phone="", get_cart=False):
        """
        Override de get_access con rotaci√≥n autom√°tica
        """
        if self._len_proxy == 0:
            logger.error("‚ùå No hay proxies disponibles")
            return False
        
        # Intentar obtener acceso con rotaci√≥n
        max_attempts = 3
        
        for attempt in range(max_attempts):
            try:
                logger.info(f"üîê Intento {attempt + 1}/{max_attempts} de obtener acceso")
                
                # Llamar al m√©todo original del padre
                success = super().get_access(phone, get_cart)
                
                if success:
                    logger.info(f"‚úÖ Acceso obtenido correctamente")
                    return True
                else:
                    logger.warning(f"‚ö†Ô∏è No se pudo obtener acceso (intento {attempt + 1})")
                    
                    if attempt < max_attempts - 1:
                        # Rotar al mejor proxy
                        self._rotate_to_best_proxy()
                        self._update_session_with_current_proxy()
                        
            except Exception as e:
                logger.error(f"‚ùå Error obteniendo acceso: {e}")
                
                if attempt < max_attempts - 1:
                    self._rotate_to_best_proxy()
                    self._update_session_with_current_proxy()
        
        logger.error(f"‚ùå No se pudo obtener acceso despu√©s de {max_attempts} intentos")
        return False
    
    def get_phone_number(self, phone):
        """
        Override de get_phone_number con rotaci√≥n autom√°tica
        """
        if self._len_proxy == 0:
            return (500, "No hay proxies disponibles")
        
        max_attempts = 3
        last_error = None
        
        for attempt in range(max_attempts):
            try:
                logger.info(f"üìû Consultando {phone} (intento {attempt + 1}/{max_attempts})")
                
                # Llamar al m√©todo original
                result = super().get_phone_number(phone)
                
                # Verificar el resultado
                if isinstance(result, tuple) and len(result) == 2:
                    status_code, data = result
                    
                    if status_code in [200, 404]:
                        # √âxito
                        logger.info(f"‚úÖ {phone} procesado: status {status_code}")
                        return result
                    else:
                        last_error = f"Status {status_code}"
                        logger.warning(f"‚ö†Ô∏è Status inesperado: {status_code}")
                else:
                    last_error = "Formato de respuesta inv√°lido"
                    logger.warning(f"‚ö†Ô∏è Formato inv√°lido: {result}")
                
                # Si llegamos aqu√≠, hubo un problema - rotar
                if attempt < max_attempts - 1:
                    logger.info(f"üîÑ Rotando proxy para siguiente intento")
                    self._rotate_to_best_proxy()
                    self._update_session_with_current_proxy()
                    
                    # Re-obtener acceso con nuevo proxy
                    if not self.get_access("", get_cart=False):
                        logger.warning(f"‚ö†Ô∏è No se pudo obtener acceso con nuevo proxy")
                        continue
                
            except Exception as e:
                last_error = str(e)
                logger.error(f"‚ùå Error consultando {phone}: {e}")
                
                if attempt < max_attempts - 1:
                    self._rotate_to_best_proxy()
                    self._update_session_with_current_proxy()
        
        logger.error(f"‚ùå {phone} fall√≥ despu√©s de {max_attempts} intentos. √öltimo error: {last_error}")
        return (500, f"ERROR_SCRAPING: {last_error}")
    
    def enable_rotation(self):
        """Habilita la rotaci√≥n autom√°tica"""
        self.rotation_enabled = True
        logger.info("‚úÖ Rotaci√≥n autom√°tica habilitada")
    
    def disable_rotation(self):
        """Deshabilita la rotaci√≥n autom√°tica"""
        self.rotation_enabled = False
        logger.info("‚ö†Ô∏è Rotaci√≥n autom√°tica deshabilitada")
    
    def get_rotation_stats(self):
        """Obtiene estad√≠sticas de rotaci√≥n"""
        return self.rotator.get_stats()


# Funci√≥n auxiliar para crear DigiPhone con rotaci√≥n
def create_digiphone_with_rotation(user, reprocess=False):
    """
    Factory function para crear DigiPhone con rotaci√≥n
    
    Uso:
        digiPhone = create_digiphone_with_rotation(user)
    """
    return DigiPhoneWithRotation(user, reprocess)
